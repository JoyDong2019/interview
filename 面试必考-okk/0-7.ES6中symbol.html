<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  1、引入symbol的原因
  ES5的对象属性名都是字符串，容易造成属性名的冲突。symbol保证每个属性的名字都是独一无二的，这样就从根本上防止属性名的冲突。symbol值不是对象，不能添加属性。
  symbol是一种类似于字符串的数据类型。
  symbol可以接受一个字符串作为参数，表示对symbol实例的描述。目的：在控制台显示，或者转为字符串时，比较容易区分。
  --------------------------------------------------------------------------------------------
  symbol函数的参数只是对当前symbol值的描述，因此相同参数的symbol函数的返回值是不相等的。
  symbol值可以显式转换为字符串，也可以转为布尔值，但不能转为数值。
  <script>
    // 没有参数的情况
    let s1 = Symbol();
    let s2 = Symbol();
    s1 === s2; // false
    // 有参数的情况
    let s1 = Symbol("foo");
    let s2 = Symbol("foo");
    s1 === s2; // false
  </script>
  --------------------------------------------------------------------------------------------
  2、symbol.prototype.description
  <script>
    const sym = Symbol("foo");
    sym.description; // "foo"
    //实例属性description可以直接返回symbol的描述
  </script>
  --------------------------------------------------------------------------------------------
  3、作为属性名的symbol 将对象的属性名指定为一个symbol值
  <script>
    let mySymbol = Symbol();
    // 第一种写法
    let a = {};
    a[mySymbol] = "Hello!";
    // 第二种写法
    let a = {
      [mySymbol]: "Hello!",
      //在对象内部使用symbol值定义属性时，symbol值必须放在方括号中
    };
    // 第三种写法
    let a = {};
    Object.defineProperty(a, mySymbol, { value: "Hello!" });
    // 以上写法都得到同样结果
    a[mySymbol]; // "Hello!"
  </script>
  --------------------------------------------------------------------------------------------
  4、属性名的遍历 symbol作为属性名，遍历对象的时候，该属性不会出现在for...in,
  for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。Object.getOwnPropertySymbols()方法，可以获取指定对象的所有Symbol属性名。
  该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
  Reflect.ownKeys()可以返回所有类型的键名，包括常规键名和symbol键名。 Symbol
  值作为键名，不会被常规方法遍历得到：
  <script>
    let size = Symbol("size");
    class Collection {
      constructor() {
        this[size] = 0;
      }
      add(item) {
        this[this[size]] = item;
        this[size]++;
      }
      static sizeOf(instance) {
        return instance[size];
      }
    }
    let x = new Collection();
    Collection.sizeOf(x); // 0
    x.add("foo");
    Collection.sizeOf(x); // 1
    Object.keys(x); // ['0']
    Object.getOwnPropertyNames(x); // ['0']
    Object.getOwnPropertySymbols(x); // [Symbol(size)]
  </script>
  --------------------------------------------------------------------------------------------
  5、Symbol.for(),Symbol.keyFor() 重新使用同一个symbol值
  Symbol.for()与Symbol()这两种写法，都会生成新的//Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的//Symbol类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for("cat")30次，每次都会返回同一个Symbol//值，但是调用Symbol("cat")30次，会返回30//个不同的Symbol//值。
  <script>
    Symbol.for("bar") === Symbol.for("bar");
    // true
    Symbol("bar") === Symbol("bar");
    // false
    let s1 = Symbol.for("foo");
    Symbol.keyFor(s1); // "foo"
    let s2 = Symbol("foo");
    Symbol.keyFor(s2); // undefined
    //Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的key
  </script>
  --------------------------------------------------------------------------------------------
  6、内置的symbol值
  --------------------------------------------------------------------------------------------
  1.Symbol.hasInstance()--------
  对象的Symbol.hasInstance属性，指向一个内部方法。
  <script>
    function MyObject() {
      // empty
    }
    Object.defineProperty(MyObject, Symbol.hasInstance, {
      value: function (v) {
        //console.log(v);   //MyObject {}
        return false;
      },
    });
    let obj = new MyObject();
    console.log(obj instanceof MyObject); // false
    /*
     * obj实际上是MyObject的实例，但是我们将Symbol.hasInstance的返回值硬编码为false以后
     * 即使使用instanceof运算符也只是返回false
     */
    //可以重构Symbol.hasInstance()
  </script>
  2、Symbol.isConcatSpreadable()
  对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。数组的默认行为是可以展开，Symbol.isConcatSpreadable默认等于undefined。该属性等于true时，也有展开的效果。类似数组的对象正好相反，默认不展开。它的Symbol.isConcatSpreadable属性设为true，才可以展开。
  <script>
    /*数组对象*/
    let arr1 = ["c", "d"];
    ["a", "b"].concat(arr1, "e"); // ['a', 'b', 'c', 'd', 'e']
    arr1[Symbol.isConcatSpreadable]; // undefined
    let arr2 = ["c", "d"];
    arr2[Symbol.isConcatSpreadable] = false;
    ["a", "b"].concat(arr2, "e"); // ['a', 'b', ['c','d'], 'e']
    /*类似数组对象*/
    let obj = { length: 2, 0: "c", 1: "d" };
    ["a", "b"].concat(obj, "e"); // ['a', 'b', obj, 'e']
    obj[Symbol.isConcatSpreadable] = true;
    ["a", "b"].concat(obj, "e"); // ['a', 'b', 'c', 'd', 'e']
  </script>
</html>
