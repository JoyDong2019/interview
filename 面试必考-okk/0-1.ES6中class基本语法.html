<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //生成实例对象的传统方法
      function Point(x, y) {
        this.x = x;
        this.y = y;
      }
      Point.prototype.toString = function () {
        return "(" + this.x + "," + this.y + ")";
      };
      var p = new Point(1, 2);

      //ES6引入了Class(类)的概念，可以看成是一个语法糖
      class Point {
        constructor(x, y) {
          //constructor()方法，即构造方法
          this.x = x;
          this.y = y;
          //this代表实例对象
        }
        toString() {
          return "(" + this.x + "," + this.y + ")";
        }
      }
      typeof Point; //function 类的数据类型就是函数
      Point === Point.prototype.constructor; //true 类本身指向构造函数
      const point = new Point(); //使用时对类使用new命令
      //--------------------------------------------------------------------------------------------
      //构造函数的prototype属性，类的所有方法都定义在类的prototype属性上面
      class Point {
        constructor() {}
        toString() {}
        toValue() {}
      }
      //与上等同
      Point.prototype = {
        constructor() {},
        toString() {},
        toValue() {},
      };
      //---------------------------------------------------------------------------------------
      class B {}
      const b = new B();
      b.constructor === B.prototype.constructor; //true
      //b是B类的实例，它的constructor()方法就是B类原型的constructor()方法
      //-------------------------------------------------------------------------------------
      class Point {
        constructor() {}
      }
      Object.assign(Point.prototype, { toString() {}, toValue() {} });
      //由于类的方法都定义在prototype对象上面，因此类的新方法可以添加在prototype对象上面。Object.assign()可以很方便地一次性向类添加多个方法。
      // ----------------------------------------------------------------------------------
      // constructor() 一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加
      class Foo {
        constructor() {
          //constructor()方法默认返回实例对象(this)，但是可以返回另一个对象
          return Object.create(null);
        }
      }
      new Foo() instanceof Foo; //false
      //补充instanceof:用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上
      //object instanceof constructor : object:某个实例对象 constructor：某个构造函数

      //----------------------------------------------------------------------------
      // 类的实例
      //实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。
      //定义类
      class Point {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          //x和y是实例对象point自身的属性(定义在this对象上)
        }

        toString() {
          return "(" + this.x + ", " + this.y + ")";
          //toString()是对象原型的属性，因为定义在Point类上。
        }
      }

      var point = new Point(2, 3);

      point.toString(); // (2, 3)

      point.hasOwnProperty("x"); // true
      point.hasOwnProperty("y"); // true
      point.hasOwnProperty("toString"); // false，tostring()定义在其原型链上，是自身属性
      point.__proto__.hasOwnProperty("toString"); // true
      //obj.hasOwnProperty()：所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。
    </script>
    ----------------------------------------------------------------------------------------
    constructor()方法
    constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。
    返回值：constructor()方法默认返回实例对象(即this),完全可以返回另一个对象
    <script>
      class Foo {
        constructor() {
          return Object.create(null);
        }
      }
      new Foo() instanceof Foo; //false
      //Foo() typeError: Class constructor Foo cannot be invoked without 'new'
      //必须用new调用，否则报错
      //constructor()函数返回一个全新的对象，结果导致实例对象不是Foo类的实例
    </script>
    类的所有实例都共享一个原型对象
    <script>
      var p1 = new Point(2, 3);
      var p2 = new Point(3, 4);
      p1.__proto__ === p2.__proto__;
      //不建议通过实例的__proto__属性为类添加方法
      //可以使用Object.getPropertyOf(object)方法返回指定对象的原型，然后再为原型添加方法和属性。
      p1.__proto__.printName = function () {
        return "Oops";
      };
      p1.printName(); //"Oops"
    </script>
    p1和p2的原型都是Point.prototype。可以通过实例的__proto__属性为”类“添加方法。一般不采用。__proto__并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的
    JS
    引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。
    -----------------------------------------------------------------------------------
    取值函数(getter)和存值函数(setter) getter():负责返回有效的值
    setter():负责如何处理数据
    <script>
      class MyClass {
        constructor() {}
        get prop() {
          return "getter";
        }
        set prop(){
          console.log("setter"+value);
        }
      }
      let inst=new MyClass();
      inst.prop=123;//setter:123
      inst.prop;//"getter"
    </script>
    ----------------------------------------------------------------------------------------
    this 指向 类的方法内部如果含有this，它默认指向类的实例。
    <script>
      class Logger {
        printName(name = "there") {
          this.print(`Hello ${name}`);
        }

        print(text) {
          console.log(text);
        }
      }

      const logger = new Logger();
      const { printName } = logger;
      printName(); // TypeError: Cannot read property 'print' of undefined
      //方法提取出来单独使用，this会指向该方法运行时所在的环境。
    </script>
    解决办法： (1)在构造方法中绑定this
    (2)使用箭头函数：箭头函数内部的this总是指向定义时所在的对象。箭头函数位于构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以this会总是指向实例对象。
    ----------------------------------------------------------------------------------------
    静态方法
    所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。
    <script>
      class Foo {
        static classMethod() {
          this.classMethod();
          /* 如果静态方法中包含this关键字，这个this指的是类，而不是实例。 */
          return "hello";
        }
      }
      Foo.classMethod(); //"hello"
      var foo = new Foo();
      foo.classMethod();
      // TypeError: foo.classMethod is not a function
    </script>
    <script>
      class Foo {
        static bar() {
          this.baz();
        }
        static baz() {
          console.log("hello");
        }
        baz() {
          console.log("world");
        }
      }
      Foo.bar(); // hello
    </script>
    静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。
    父类的静态方法可以被子类继承。
    <script>
      class Foo {
        static classMethod() {
          return "hello";
        }
      }
      class Bar extends Foo {}
      Bar.classMethod(); // 'hello'
    </script>
    ----------------------------------------------------------------------------------------
    实例属性的新写法
    实例属性可以定义在类的最顶层，且不需要在实例属性前面加上this
    <script>
      class IncreasingCounter {
        //实例属性写在最顶层且不需要加上this关键字
        _count = 0;
        get value() {
          console.log("Getting the current value!");
          return this._count;
        }
        increment() {
          this._count++;
        }
      }
    </script>
    ----------------------------------------------------------------------------------------
    静态属性
    Class本身的属性，即Class.propName,而不是定义在实例对象(this)上的属性。
    <script>
      // 老写法
      class Foo {
        // ...
      }
      Foo.prop = 1;
      // 新写法
      class Foo {
        static prop = 1;
      }
    </script>
    ----------------------------------------------------------------------------------------
    私有方法和私有属性 只能在类的内部访问的属性和方法，外部不能访问
    <script>
      class Widget {
        // 公有方法
        foo(baz) {
          this._bar(baz);
        }

        // 私有方法
        _bar(baz) {
          return (this.snaf = baz);
        }

        // ...
      }
    </script>
    私有属性,#a,#b是私有属性；#sum是私有方法。
    <script>
      class Foo {
        #a;
        #b;
        constructor(a, b) {
          this.#a = a;
          this.#b = b;
        }
        #sum() {
          return this.#a + this.#b;
        }
        printSum() {
          console.log(this.#sum());
        }
      }
    </script>
    ----------------------------------------------------------------------------------------
    new.target属性
    new是从构造函数生成实例对象的命令。ES6为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。
    <script>
      function Person(name) {
        if (new.target !== undefined) {
          this.name = name;
        } else {
          throw new Error("必须使用 new 命令生成实例");
        }
      }

      // 另一种写法
      function Person(name) {
        if (new.target === Person) {
          this.name = name;
        } else {
          throw new Error("必须使用 new 命令生成实例");
        }
      }

      var person = new Person("张三"); // 正确
      var notAPerson = Person.call(person, "张三"); // 报错
      //保证构造函数只能通过new命令调用
    </script>
    子类继承父类时，new.target
    会返回子类。利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。
    <script>
      class Shape {
        constructor() {
          if (new.target === Shape) {
            throw new Error("本类不能实例化");
          }
        }
      }

      class Rectangle extends Shape {
        constructor(length, width) {
          super();
          // ...
        }
      }
      var x = new Shape(); // 报错
      var y = new Rectangle(3, 4); // 正确
      //shape类不能被实例化，只能用于继承。
    </script>
    ------------------------------------------------------------------------------------------
    补充：可枚举属性和不可枚举属性
    可枚举和不可枚举是由属性的enumerable值决定的。可枚举性决定这个属性能否被for...in查找遍历到。Object对象的propertyIsEnumerable()方法可以判断此对象是否包含某个属性，并且这个属性是否可枚举。需要注意的是：如果判断的属性存在于Object对象的原型内，不管它是否可枚举都会返回false。
    ------------------------------------------------------------------------------------------
    1、JS中基本包装类型的原型属性都是不可枚举的，如Object、Array、Number等。
    2、类的内部定义的所有方法都是不可枚举的
    ------------------------------------------------------------------------------------------
    枚举方法的区别：
    1.for…in循环可以枚举(遍历)出对象本身具有的属性，通过Object.defineProperty()方法加的可枚举属性，或者通过原型对象绑定的可以枚举属性(即继承的属性)。
    2.Object.keys()方法可以枚举对象本身的属性和通过Object.defineProperty()添加的可枚举属性。Object.keys()会返回一个由一个给定对象的自身可枚举属性组成的数组
    3.JSON.stringify()方法只能序列化本身的属性和通过Object.defineProperty()添加的可枚举属性为JSON对象。
    4.Object.getOwnPropertyNames()返回一个由指定对象的所有自身属性的属性名(包括不可枚举属性但不包括symbol值作为名称的属性)组成的数组。
    -----------------------------------------------------------------------------------------
    设置可枚举属性 Object.defineProperty() 1.Object.defineProperty(obj, prop,
    descriptor)方法有三那个参数 第一个：目标对象 第二个：目标属性，字符串
    第三个：对目标属性的行为，放在对象里
    2.enumerable为true时表示可枚举，enumerable为false表示不可枚举；
    3.开发者自己定义的对象person中的所有属性默认都是可枚举的；
    <script>
      var person = {
        name: "xiao",
        age: "18",
        sex: "boy",
      };
      Object.defineProperty(person, "age", {
        enumerable: true, //可以被枚举
      });
      Object.defineProperty(person, "sex", {
        enumerable: false, //不可以被枚举
      });
      for (var k in person) {
        console.log(person[k]); //18,xiao
        //开发者自己定义的对象person的所有属性都是默认可枚举的
      }
    </script>
  </body>
</html>
