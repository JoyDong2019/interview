<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //生成实例对象的传统方法
      function Point(x, y) {
        this.x = x;
        this.y = y;
      }
      Point.prototype.tostring = function () {
        return "(" + this.x + "," + this.y + ")";
      };
      var p = new Point(1, 2);

      //ES6引入了Class(类)的概念，可以看成是一个语法糖
      class Point {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          //this代表实例对象
        }
        tostring() {
          return "(" + this.x + "," + this.y + ")";
        }
      }
      typeof Point; //function 类的数据类型就是函数
      Point === Point.prototype.constructor; //true 类本身指向构造函数
      const point = new Point(); //使用时对类使用new命令

      //构造函数的prototype属性，类的所有方法都定义在类的prototype属性上面
      class Point {
        constructor() {}
        tostring() {}
        toValue() {}
      }
      //与上等同
      Point.prototype = {
        constructor() {},
        tostring() {},
        toValue() {},
      };

      class Point {
        constructor() {}
      }
      Object.assign(Point.prototype, { toString() {}, toValue() {} });
      //由于类的方法都定义在prototype对象上面，因此类的新方法可以添加在prototype对象上面。Object.assign()可以很方便地一次性向类添加多个方法。
      // ----------------------------------------------------------------------------------
      // constructor() 一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加
      class Foo {
        constructor() {
          //constructor()方法默认返回实例对象(this)，但是可以返回另一个对象
          return Object.creat(null);
        }
      }
      new Foo() instanceof Foo;
      //补充instanceof:用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上
      //object instanceof constructor : object:某个实例对象 constructor：某个构造函数

      //----------------------------------------------------------------------------
      // 类的实例
      //实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。
      //定义类
      class Point {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          //x和y是实例对象point自身的属性(定义在this对象上)
        }

        toString() {
          return "(" + this.x + ", " + this.y + ")";
          //toString()是对象原型的属性，因为定义在Point类上。
        }
      }

      var point = new Point(2, 3);

      point.toString(); // (2, 3)

      point.hasOwnProperty("x"); // true
      point.hasOwnProperty("y"); // true
      point.hasOwnProperty("toString"); // false，tostring()定义在其原型链上，是自身属性
      point.__proto__.hasOwnProperty("toString"); // true
      //obj.hasOwnProperty()：所有继承了 Object 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性；和 in 运算符不同，该方法会忽略掉那些从原型链上继承到的属性。
    </script>
    ----------------------------------------------------------------------------------------
    constructor()方法
    constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。
    返回值：constructor()方法默认返回实例对象(即this),完全可以返回另一个对象
    <script>
      class Foo {
        constructor() {
          return Object.create(null);
        }
      }
      new Foo() instanceof Foo; //false
      //Foo() typeError: Class constructor Foo cannot be invoked without 'new'
      //必须用new调用，否则报错
      //constructor()函数返回一个全新的对象，结果导致实例对象不是Foo类的实例
    </script>
    类的所有实例都共享一个原型对象
    <script>
      var p1 = new Point(2, 3);
      var p2 = new Point(3, 4);
      p1.__proto__ === p2.__proto__;
      //不建议通过实例的__proto__属性为类添加方法
      //可以使用Object.getPropertyOf(object)方法返回指定对象的原型，然后再为原型添加方法和属性。
      p1.__proto__.printname = function () {
        return "Oops";
      };
      p1.printname(); //"Oops"
    </script>
    p1和p2的原型都是Point.prototype。可以通过实例的__proto__属性为”类“添加方法。一般不采用
    -----------------------------------------------------------------------------------
    取值函数(getter)和存值函数(setter) getter():负责返回有效的值
    setter():负责如何处理数据
    <script>
      class MyClass {
        constructor() {}
        get prop() {
          return "getter";
        }
        set prop(){
          console.log("setter"+value);
        }
      }
      let inst=new MyClass();
      inst.prop=123;//setter:123
      inst.prop;//"getter"
    </script>
    ----------------------------------------------------------------------------------------
    this 指向 类的方法内部如果含有this，它默认指向类的实例。
    <script>
      class Logger {
        printName(name = "there") {
          this.print(`Hello ${name}`);
        }

        print(text) {
          console.log(text);
        }
      }

      const logger = new Logger();
      const { printName } = logger;
      printName(); // TypeError: Cannot read property 'print' of undefined
      //方法提取出来单独使用，this会指向该方法运行时所在的环境。
    </script>
    解决办法： (1)在构造方法中绑定this
    (2)使用箭头函数：箭头函数内部的this总是指向定义时所在的对象。箭头函数位于构造函数内部，它的定义生效的时候，是在构造函数执行的时候。这时，箭头函数所在的运行环境，肯定是实例对象，所以this会总是指向实例对象。
    ----------------------------------------------------------------------------------------
    静态方法
    所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。
    <script>
      class Foo {
        static classMethod() {
          this.classMethod();
          //如果静态方法中包含this关键字，这个this指的是类，而不是实例。
          return "hello";
        }
      }
      Foo.classMethod(); //"hello"
      var foo = new Foo();
      foo.classMethod();
      // TypeError: foo.classMethod is not a function
    </script>
    <script>
      class Foo {
        static bar() {
          this.baz();
        }
        static baz() {
          console.log("hello");
        }
        baz() {
          console.log("world");
        }
      }
      Foo.bar(); // hello
    </script>
    静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。
    父类的静态方法可以被子类继承。
    <script>
      class Foo {
        static classMethod() {
          return "hello";
        }
      }
      class Bar extends Foo {}
      Bar.classMethod(); // 'hello'
    </script>
    ----------------------------------------------------------------------------------------
    静态属性
    Class本身的属性，即Class.propName,而不是定义在实例对象(this)上的属性。
    <script>
      // 老写法
      class Foo {
        // ...
      }
      Foo.prop = 1;
      // 新写法
      class Foo {
        static prop = 1;
      }
    </script>
    ----------------------------------------------------------------------------------------
    私有方法和私有属性 只能在类的内部访问的属性和方法，外部不能访问
    <script>
      class Widget {
        // 公有方法
        foo(baz) {
          this._bar(baz);
        }

        // 私有方法
        _bar(baz) {
          return (this.snaf = baz);
        }

        // ...
      }
    </script>
    ----------------------------------------------------------------------------------------
    new.target属性
    new是从构造函数生成实例对象的命令。ES6为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。
    <script>
      function Person(name) {
        if (new.target !== undefined) {
          this.name = name;
        } else {
          throw new Error("必须使用 new 命令生成实例");
        }
      }

      // 另一种写法
      function Person(name) {
        if (new.target === Person) {
          this.name = name;
        } else {
          throw new Error("必须使用 new 命令生成实例");
        }
      }

      var person = new Person("张三"); // 正确
      var notAPerson = Person.call(person, "张三"); // 报错
    </script>
  </body>
</html>
