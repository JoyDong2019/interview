<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    1、generate函数：状态机，封装了多个内部状态
    2、遍历器对象生成函数：返回一个遍历器对象，代表Generator函数的内部指针，可以依次遍历generator函数内部的每一个状态
    3、function关键字与函数名之间有一个星号
    4、函数体内部使用yield表达式，定义不同的内部状态
    <script>
      function* helloWorldGenerator() {
        yield "hello";
        yield "world";
        return "endind";
        //三个状态：hello world 和 return 语句
      }
      var hw = helloWorldGenerator();
      //调用该函数 函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象
      hw.next();
      // { value: 'hello', done: false }
      //yield 表达式是暂停执行的标记 而next方法可以恢复执行
      //false属性表示遍历还没有结束
      hw.next();
      // { value: 'world', done: false }
      hw.next();
      // { value: 'ending', done: true }
      hw.next();
      // { value: undefined, done: true }
    </script>
    yield表达式
    （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。
    （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。
    （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。
    （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。
    yield表达式只能用在Generator函数里面，用在其他地方都会报错。
    <script>
      var arr = [1, [[2, 3], 4], [5, 6]];
      var flat = function* (a) {
        a.forEach(function (item) {//会产生语法错误
          //forEach方法的参数是一个普通函数，不能用yield，可以改用for循环
          if (typeof item !== 'number') {
            yield* flat(item);
          } else {
            yield item;
          }
        });
      };
      for (var f of flat(arr)){
        console.log(f);
      }
    </script>
    yield表达式如果在另一个表达式中，必须放在圆括号里面
    ----------------------------------------------------------------------------------------
    与Iterator接口的关系
    <script>
      var myIterable = {};
      myIterable[Symbol.iterator] = function* () {
        yield 1;
        yield 2;
        yield 3;
      };
      [...myIterable]; // [1, 2, 3]
      //Generator 函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了 Iterator 接口，可以被...运算符遍历了
    </script>
    ----------------------------------------------------------------------------------------
    next方法的参数 yield
    本身没有返回值，或者说总是返回undefined。next方法可以带上一个参数，该参数会被当做上一个yield表达式的返回值。
    <script>
      function* f() {
        for (var i = 0; true; i++) {
          var reset = yield i;
          if (reset) {
            i = -1;
          }
        }
      }
      var g = f();
      g.next(); // { value: 0, done: false }
      g.next(); // { value: 1, done: false }
      g.next(true); // { value: 0, done: false}
    </script>
    <script>
      function* foo(x) {
        var y = 2 * (yield x + 1);
        var z = yield y / 3;
        return x + y + z;
      }
      var a = foo(5);
      a.next(); // Object{value:6, done:false}
      a.next(); // Object{value:NaN, done:false}
      //第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN）
      a.next(); // Object{value:NaN, done:true}
      var b = foo(5);
      b.next(); // { value:6, done:false }
      b.next(12); // { value:8, done:false }
      b.next(13); // { value:42, done:true }
    </script>
    --------------------------------------------------------------------------------------
    for...of循环
    <br />for...of循环可以自动遍历Generator函数运行时生成的Iterator对象，且此时不再需要调用next方法。
    <script>
      function* foo() {
        yield 1;
        yield 2;
        yield 3;
        yield 4;
        yield 5;
        return 6;
      }
      for (let v of foo()) {
        //如果next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以返回结果中6不包括在for...of循环之中
        console.log(v);
      }
      // 1 2 3 4 5
    </script>
    加上遍历器接口：通过generator函数
    <script>
      function* objectEntries(obj) {
        let propKeys = Reflect.ownKeys(obj);
        for (let propKey of propKeys) {
          yield [propKey, obj[propKey]];
        }
      }
      let jane = { first: "Jane", last: "Doe" };
      for (let [key, value] of objectEntries(jane)) {
        console.log(`${key}: ${value}`);
      }
      /* jane[Symbol.iterator] = objectEntries;
      for (let [key, value] of jane) {
        console.log(`${key}: ${value}`);
      } */
      //两种写法
    </script>
    对象Jane原生不具备Iterator接口，无法用for...of 遍历。
    只要有遍历器接口：扩展运算符(...)、解构赋值和Array.from()都可以调用。可将Generator函数返回的Iterator对象作为参数。
    <script>
      function* numbers() {
        yield 1;
        yield 2;
        return 3;
        yield 4;
      }
      // 扩展运算符
      [...numbers()]; // [1, 2]
      // Array.from 方法
      Array.from(numbers()); // [1, 2]
      // 解构赋值
      let [x, y] = numbers();
      x; // 1
      y; // 2
      // for...of 循环
      for (let n of numbers()) {
        console.log(n);
      }
      // 1
      // 2
      //next方法返回的对象的done属性为true，上述方法就会中止，且不包含该返回对象。
    </script>
    ---------------------------------------------------------------------------------------
    Generator.prototype.throw()
    Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。如果Generator函数内部没有部署try...catch代码块，那么throw方法抛出的错误将被外部try...catch代码块捕获。throw方法抛出的错误要被内部捕获，必须至少执行过一次next方法。throw方法被捕获之后，会附带执行下一条yield表达式，即附带执行一次next方法。
    <script>
      var g = function* () {
        try {
          yield;
        } catch (e) {
          console.log("内部捕获", e);
        }
      };
      var i = g();
      i.next();
      try {
        i.throw("a");
        i.throw("b");
        //遍历器i连续抛出两个错误
      } catch (e) {
        console.log("外部捕获", e);
      }
      // 内部捕获 a 第一个错误被Generator函数体内的catch语句捕获
      // 外部捕获 b 第二个错误由于Generator函数内部的catch语句已经执行过了，不会再捕捉到这个错误，故错误被抛出了Generator函数体，被函数体外的catch语句捕获。
    </script>
    不要混淆遍历器对象的throw方法和全局的throw命令。throw命令抛出的只能被函数体外的catch语句捕获。
    <script>
      function* foo() {
        var x = yield 3;
        var y = x.toUpperCase();
        yield y;
      }
      var it = foo();
      it.next(); // { value:3, done:false }
      try {
        it.next(42);
        //第二个next方法向函数体内传入一个参数42，数值是没有toUpperCase方法的，所以会抛出一个 TypeError 错误，被函数体外的catch捕获。
        //Generator执行过程中抛出错误且没有被内部捕获，就不会再执行下去。
      } catch (err) {
        console.log(err);
      }
    </script>
    ---------------------------------------------------------------------------------------
    Generator.prototype.return()
    <br />Generator函数返回的遍历器对象，还有一个return()方法，可以返回给定的值，并且终结遍历
    Generator 函数。
    <script>
      function* gen() {
        yield 1;
        yield 2;
        yield 3;
      }
      var g = gen();
      g.next(); // { value: 1, done: false }
      g.return("foo"); // { value: "foo", done: true }
      //如果return方法不提供参数，则返回的value属性为undefined
      g.next(); // { value: undefined, done: true }
    </script>
    如果有try...finally代码块，且正在执行try代码块，那么return()方法会导致立刻进入finally代码块，执行完之后，整个函数才会结束。
    <script>
      function* numbers() {
        yield 1;
        try {
          yield 2;
          yield 3;
        } finally {
          yield 4;
          yield 5;
        }
        yield 6;
      }
      var g = numbers();
      g.next(); // { value: 1, done: false }
      g.next(); // { value: 2, done: false }
      g.return(7); // { value: 4, done: false }
      g.next(); // { value: 5, done: false }
      g.next(); // { value: 7, done: true }
    </script>
    --------------------------------------------------------------------------------------
    yield* 表达式
    在Generator函数内部，调用另一个Generator函数。需要在前者的函数体内部，自己手动完成遍历。如果yield表达式后面跟着的是一个遍历器对象，需要在yield表达式后面加上星号，表明其返回的是一个遍历器对象，即为yield*表达式。任何数据只要有Iterator接口，就可以被yield*遍历。
    <script>
      function* foo() {
        yield "a";
        yield "b";
      }
      function* bar() {
        yield "x";
        // 手动遍历 foo()
        for (let i of foo()) {
          console.log(i);
        }
        yield "y";
      }
      for (let v of bar()) {
        console.log(v);
      }
      // x
      // a
      // b
      // y
      //在bar里面调用foo，需要手动遍历foo。如果有多个Generator函数嵌套，写起来非常麻烦
    </script>
    <script>
      function* bar() {
        yield "x";
        yield* foo();
        yield "y";
      }
      // 等同于
      function* bar() {
        yield "x";
        yield "a";
        yield "b";
        yield "y";
      }
      // 等同于
      function* bar() {
        yield "x";
        for (let v of foo()) {
          yield v;
        }
        yield "y";
      }
      for (let v of bar()) {
        console.log(v);
      }
      // "x"
      // "a"
      // "b"
      // "y"
    </script>
    <script>
      let delegatedIterator = (function* () {
        yield "Hello!";
        yield "Bye!";
      })();
      let delegatingIterator = (function* () {
        yield "Greetings!";
        yield* delegatedIterator;
        //遍历了多个Generator函数，有递归效果。
        //yield命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。
        yield "Ok, bye.";
      })();
      for (let value of delegatingIterator) {
        console.log(value);
      }
      // "Greetings!
      // "Hello!"
      // "Bye!"
      // "Ok, bye."
    </script>
    //被代理的Generator函数有return语句，可以向代理它的Generator函数返回数据。
    <script>
      function* foo() {
        yield 2;
        yield 3;
        return "foo";
      }
      function* bar() {
        yield 1;
        var v = yield* foo();
        console.log("v: " + v);
        yield 4;
      }
      var it = bar();
      it.next();
      // {value: 1, done: false}
      it.next();
      // {value: 2, done: false}
      it.next();
      // {value: 3, done: false}
      it.next();
      // "v: foo"  return 语句返回的对象
      // {value: 4, done: false}
      it.next();
      // {value: undefined, done: true}
    </script>
    ---------------------------------------------------------------------------------------
    作为对象属性的Generator函数 如果一个对象的属性是Generator函数：
    <script>
      let obj = {
        *myGeneratorMethod() {},
      };
      //等价于
      let obj = {
        myGeneratorMethod: function* () {},
      };
    </script>
    ----------------------------------------------------------------------------------------
    Generator函数的this
    Generator函数总是返回一个遍历器，这个遍历器是Generator函数的实例，且继承了Generator函数prototype对象上的方法。
    <script>
      function* g() {}
      //g返回的是遍历器对象而不是this对象
      g.prototype.hello = function () {
        return "hi!";
      };
      let obj = g();
      obj instanceof g; // true
      obj.hello(); // 'hi!'
    </script>
    让Generator函数返回一个正常的实例对象，既可以用next方法，又可以获得正常的this。
    <script>
      function* F() {
        this.a = 1;
        yield (this.b = 2);
        yield (this.c = 3);
      }
      var obj = {};
      var f = F.call(obj);
      //F内部的this对象绑定obj对象，然后调用，返回一个Iterator对象。这个对象执行三次next方法（因为F内部有两个yield表达式），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。
      f.next(); // Object {value: 2, done: false}
      f.next(); // Object {value: 3, done: false}
      f.next(); // Object {value: undefined, done: true}
      obj.a; // 1
      obj.b; // 2
      obj.c; // 3
    </script>
    上述代码执行的是遍历器对象f，生成的对象实例是obj。 将上述两个对象统一。
    <script>
      function* F() {
        this.a = 1;
        yield (this.b = 2);
        yield (this.c = 3);
      }
      var f = F.call(F.prototype);
      f.next(); // Object {value: 2, done: false}
      f.next(); // Object {value: 3, done: false}
      f.next(); // Object {value: undefined, done: true}
      f.a; // 1
      f.b; // 2
      f.c; // 3
    </script>
  </body>
</html>
