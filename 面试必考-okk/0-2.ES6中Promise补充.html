<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  异步操作：每一个任务有一个或多个回调函数，前一个任务结束后，不是执行后一个任务，而是执行回调函数。后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序和任务的排列顺序是不一致的，异步的。
    1、理解Promise 
    <br>>简单来说，Promise就是一个容器，里面保存着未来才会结束的事件,一个异步操作的结果。Promise对象本质是一个构造函数。
    2、Promise对象的特点
    (1)对象的状态不受外界的影响。三种状态：pending(进行中)、fulfilled(已成功)、rejected(已失败)
    (2)一旦状态改变，就不会再变。
    3、基本用法
    <script>
      const promise=new Promise((resolve,reject)=>{
        if(/* 异步操作成功 */true){
          resolve(value);
        }else{
          reject(error);
        }
      })
      promise.then((value)=>{
        //success
      },(error)=>{
        //failure
      })
    </script> 
    resolve函数：将Promise对象的状态从“未完成”变为“成功”，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用，将Promise对象的状态从“未完成”变为“失败”，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
    then方法接收两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。这两个函数都是可选的，不一定要提供。它们都接受Promise对象传出的值作为参数。
    </body>
    4、用promise实现AJAX操作
    <script>
      const getJSON = function (url) {
        const promise = new Promise(function (resolve, reject) {
          const handler = function () {
            if (this.readyState !== 4) {
              return;
            }
            if (this.status === 200) {
              resolve(this.response);
            } else {
              reject(new Error(this.statusText));
            }
          };
          const client = new XMLHttpRequest();
          client.open("GET", url);
          client.onreadystatechange = handler;
          client.responseType = "json";
          //responseType 枚举类型的属性，返回相应数据的类型。允许手动设置返回数据的类型
          //"json"：response 是一个 JavaScript 对象。这个对象是通过将接收到的数据类型视为 JSON 解析得到的。
          client.setRequestHeader("Accept", "application/json");
          //XMLHttpRequest.setRequestHeader(header,value)是设置HTTP请求头部的方法。此方法必须在open()方法和 send()之间调用。header:属性的名称；value:属性的值。
          client.send();
        });

        return promise;
      };

      getJSON("/posts.json").then(
        function (json) {
          console.log("Contents: " + json);
        },
        function (error) {
          console.error("出错了", error);
        }
      );
    </script>
    5、Promise.prototype.then()
    Promise实例具有then方法，即then方法是定义在原型对象Promise.prototype上的。其作用是为Promise实例添加状态改变时的回调函数。
    <script>
      getJSON("/posts.json")
        .then(function (json) {
          return json.post;
        })
        .then(function (post) {
          // ...
        });
    </script>
    指定两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。
    ---------------------------------------------------------------------------------------
    6、Promise.prototype.catch() 
    Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。
    <script>
      getJSON("/posts.json")
        .then(function (posts) {
          // ...
        })
        .catch(function (error) {
          // 处理 getJSON 和 前一个回调函数运行时发生的错误
          console.log("发生错误！", error);
        });
    </script>
    上面代码中，getJSON()方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then()方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch()方法指定的回调函数，处理这个错误。另外，then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。
    一般来说，Promise对象后面要跟catch()方法，这样可以处理Promise内部发生的错误。catch()方法返回的还是一个Promise对象，后面可以接着调用then()方法。
    ----------------------------------------------------------------------------------------
    7、Promise.prototype.finally()
    finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。finally()方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。
    两种情况：
    a-----------------------------------------------------------
    <script>
      promise.then(result=>{}).catch(error=>{}).finally(()=>{})
    </script>
    不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。
    b-------------------------------------------------------------
    <script>
      Promise.prototype.finally = function (callback) {
        let P = this.constructor;
        //p为构造函数，this为Promise.prototype()
        return this.then(
          (value) => P.resolve(callback()).then(() => value),
          (reason) =>
            P.resolve(callback()).then(() => {
              throw reason;
            })
        );
      };
    </script>
    <script>
      promise.finally(()=>{
        //语句
      })
    </script>
    等同于
    <script>
      promise.then(
        result=>{
          //语句
          return result
        },
        error=>{
          //语句
          throw error
        }
      )
    </script>
    ----------------------------------------------------------------------------------------
    8、Promise.all()
    Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。Promise.all()方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。
    <script>
      const p=Promise.all([p1,p2,p3])
    </script>
    p的状态由p1,p2,p3决定。
    （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。
    （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。
    ---------------------------------------------------------------------------------------
    9、Promise.any()
    Promise.any()接受一组Promise实例作为参数，包装成一个新的Promise实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。Promise.any()不会因为某个 Promise 变成rejected状态而结束，必须等到所有参数 Promise 变成rejected状态才会结束。
    <script>
      Promise.any([
        fetch("https://v8.dev/").then(() => "home"),
        fetch("https://v8.dev/blog").then(() => "blog"),
        fetch("https://v8.dev/docs").then(() => "docs"),
      ])
        .then((first) => {
          // 只要有一个 fetch() 请求成功
          console.log(first);
        })
        .catch((error) => {
          // 所有三个 fetch() 全部请求失败
          console.log(error);
        });
    </script>
    ----------------------------------------------------------------------------------------
    10、Promise.resolve()
    将现有对象转换成Promise对象
    ------------------------------------
    Promise.resolve()方法的参数分为四种情况：
    (1)参数是一个Promise实例
    Promise.resolve将不做任何修改、原封不动地返回这个实例。
    (2)参数是一个thenable对象
    thenable对象指的是具有then方法的对象。
    <script>
      let thenable = {
        then: function (resolve, reject) {
          resolve(42);
        },
      };
      let p1 = Promise.resolve(thenable);
      p1.then(function (value) {
        console.log(value); // 42
      });
    </script>
    Promise.resolve()会把这个对象转化为Promise对象，然后立即执行thenable对象的then()方法
    (3)参数不是具有then()方法的对象，或者说就不是对象
    如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。
    <script>
      const p = Promise.resolve("Hello");
      p.then(function (s) {
        console.log(s);//Hello
      });
    </script>
    上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve()方法的参数，会同时传给回调函数。
    (4)不带有任何参数
    Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。
    --------------------------------------------------------------------------------------
    11、Promise.race()
    将多个Promise实例包装成一个新的Promise实例。
    <script>
      const p=Promise.race([p1,p2,p3]);
    </script>
    上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。对于不是Promise实例，先调用Promise.resolve()方法，将参数转换成Promise实例，再进一步处理。
    ---------------------------------------------------------------------------------------
    12、Promise.allSettled()
    Promise.allSettled()接受一组Promise实例作为参数，包装成一个新的Promise实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法返回新的Promise实例，一旦结束，状态总是fulfilled，不会变成rejected。
</html>
--------------------------------------------------------------------------------------------
<script>
  const p=Promise.race([p1,p2,p3])
</script>
1、Promise.prototype.catch():.then(null,rejection)或.then(undefined,rejection)的别名，用于指定发生错误时的回调函数。推荐使用
2、Promise.prototype.finally():不管Promise对象最后的状态如何，都会执行的操作。finally()方法的回调函数不接受任何参数，没有办法知道前面Promise状态到底是fulfilled还是rejected。
3、Promise.allSettled():接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。
4、Promise.race():将多个 Promise 实例，包装成一个新的 Promise 实例。只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。
5、Promise.all()
6、Promise.any()
7、Promise.resolve()
8、Promise.reject()


